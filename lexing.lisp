(defparameter *str-keywords* (make-hash-table :test 'equal))
(defparameter *str-tokfuncs* (make-hash-table :test 'equal))

(defun add-to-hash (ht l)
  "Adds the given list l to the hashtable. Elements should be a 2-element list
  of string and result"
  (mapcar (lambda (tokstr-pair)
	    (setf (gethash (car tokstr-pair) ht)
		  (cadr tokstr-pair)))
	  l))

(defun setup-keywords ()
  "Initialises the global keyword hashtable"
  (add-to-hash *str-keywords* '(("and" AND)			
			       ("as" AS)			
			       ("assert" ASSERT)		
			       ("begin" BEGIN)
			       ("class" CLASS)			
			       ("constraint" CONSTRAINT)	
			       ("do" DO)			
			       ("done" DONE)			
			       ("downto" DOWNTO)		
			       ("else" ELSE)			
			       ("end" END)			
			       ("exception" EXCEPTION)		
			       ("external" EXTERNAL)		
			       ("false" FALSE)			
			       ("for" FOR)			
			       ("fun" FUN)			
			       ("function" FUNCTION)		
			       ("functor" FUNCTOR)		
			       ("if" IF)			
			       ("in" IN)			
			       ("include" INCLUDE)		
			       ("inherit" INHERIT)		
			       ("initializer" INITIALIZER)	
			       ("lazy" LAZY)			
			       ("let" LET)			
			       ("match" MATCH)			
			       ("method" METHOD)		
			       ("module" MODULE)		
			       ("mutable" MUTABLE)		
			       ("new" NEW)			
			       ("nonrec" NONREC)		
			       ("object" OBJECT)		
			       ("of" OF)			
			       ("open" OPEN)			
			       ("or" OR)			
			       ("private" PRIVATE)		
			       ("rec" REC)			
			       ("sig" SIG)			
			       ("struct" STRUCT)		
			       ("then" THEN)			
			       ("to" TO)			
			       ("true" TRUE)			
			       ("try" TRY)			
			       ("type" TYPE)			
			       ("val" VAL)			
			       ("virtual" VIRTUAL)		
			       ("when" WHEN)			
			       ("while" WHILE)			
			       ("with" WITH))))
;; These are actually tokens that for some reason are defined under the
;; keyword hashtable?
;;("mod" INFIXOP3("mod"))	
;;("land" INFIXOP3("land"))	
;;("lor" INFIXOP3("lor"))	
;;("lxor" INFIXOP3("lxor"))	
;;("lsl" INFIXOP4("lsl"))	
;;("lsr" INFIXOP4("lsr"))	
;;("asr" INFIXOP4("asr"))

(defun lex-alpha-string (s)
  "Lexes an alphanumeric string"
  (let ((keytok (gethash s *str-keywords*)))
    (if keytok
	(values keytok keytok)
	(values 'Identifier s))))

(lexer:deflexer ocaml-lexer
  ("[0-9]+([.][0-9]+([Ee][0-9]+)?)" (return (values 'Float (lexer:num lexer:%0))))
  ("[0-9]+" (return (values 'Int (lexer:int lexer:%0))))
  ("=" (return (values 'Equals 'Equals)))
  ("#\Newline")
  ("_" (return (values 'Underscore 'Underscore)))
  ("~" (return (values 'Tilde 'Tilde)))
  (";" (return (values 'Semi 'Semi)))
  ("\\+" (return (values 'BinOp 'Plus)))
  ("\\/\\." (return (values 'BinOp 'FloatDiv)))
  ("\\*\\." (return (values 'BinOp 'FloatMul)))
  ("\\(" (return (values 'LParen 'LParen)))
  ("\\)" (return (values 'RParen 'RParen)))
  ("\\/" (return (values 'BinOp 'IntDiv)))
  ("\\*" (return (values 'BinOp 'IntMul)))  
  ("\\-\\>" (return (values 'MinusGreater 'MinusGreater)))
  ("\\-" (return (values 'BinOp 'Minus)))
  ("[:alpha:][:alnum:]*" (return (lex-alpha-string lexer:%0)))
  ("[:space:]+")
  ("#\Newline"))

(defun debug-print-lexing (str)
  (let ((l (ocaml-lexer str)))
    (loop while (funcall l))))

(defun test-lex ()
  (ocaml-lexer "let x = 1 in x - 1"))

(setup-keywords)

